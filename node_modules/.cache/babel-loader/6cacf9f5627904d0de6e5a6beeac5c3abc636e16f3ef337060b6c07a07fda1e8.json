{"ast":null,"code":"\"use client\";\n\nimport { jsx } from 'react/jsx-runtime';\nimport { frame, microtask } from 'motion-dom';\nimport { useContext, Component } from 'react';\nimport { usePresence } from '../../../components/AnimatePresence/use-presence.mjs';\nimport { LayoutGroupContext } from '../../../context/LayoutGroupContext.mjs';\nimport { SwitchLayoutGroupContext } from '../../../context/SwitchLayoutGroupContext.mjs';\nimport { globalProjectionState } from '../../../projection/node/state.mjs';\n\n/**\n * Track whether we've taken any snapshots yet. If not,\n * we can safely skip notification of didUpdate.\n *\n * Difficult to capture in a test but to prevent flickering\n * we must set this to true either on update or unmount.\n * Running `next-env/layout-id` in Safari will show this behaviour if broken.\n */\nlet hasTakenAnySnapshot = false;\nclass MeasureLayoutWithContext extends Component {\n  /**\n   * This only mounts projection nodes for components that\n   * need measuring, we might want to do it for all components\n   * in order to incorporate transforms\n   */\n  componentDidMount() {\n    const {\n      visualElement,\n      layoutGroup,\n      switchLayoutGroup,\n      layoutId\n    } = this.props;\n    const {\n      projection\n    } = visualElement;\n    if (projection) {\n      if (layoutGroup.group) layoutGroup.group.add(projection);\n      if (switchLayoutGroup && switchLayoutGroup.register && layoutId) {\n        switchLayoutGroup.register(projection);\n      }\n      if (hasTakenAnySnapshot) {\n        projection.root.didUpdate();\n      }\n      projection.addEventListener(\"animationComplete\", () => {\n        this.safeToRemove();\n      });\n      projection.setOptions({\n        ...projection.options,\n        onExitComplete: () => this.safeToRemove()\n      });\n    }\n    globalProjectionState.hasEverUpdated = true;\n  }\n  getSnapshotBeforeUpdate(prevProps) {\n    const {\n      layoutDependency,\n      visualElement,\n      drag,\n      isPresent\n    } = this.props;\n    const {\n      projection\n    } = visualElement;\n    if (!projection) return null;\n    /**\n     * TODO: We use this data in relegate to determine whether to\n     * promote a previous element. There's no guarantee its presence data\n     * will have updated by this point - if a bug like this arises it will\n     * have to be that we markForRelegation and then find a new lead some other way,\n     * perhaps in didUpdate\n     */\n    projection.isPresent = isPresent;\n    hasTakenAnySnapshot = true;\n    if (drag || prevProps.layoutDependency !== layoutDependency || layoutDependency === undefined || prevProps.isPresent !== isPresent) {\n      projection.willUpdate();\n    } else {\n      this.safeToRemove();\n    }\n    if (prevProps.isPresent !== isPresent) {\n      if (isPresent) {\n        projection.promote();\n      } else if (!projection.relegate()) {\n        /**\n         * If there's another stack member taking over from this one,\n         * it's in charge of the exit animation and therefore should\n         * be in charge of the safe to remove. Otherwise we call it here.\n         */\n        frame.postRender(() => {\n          const stack = projection.getStack();\n          if (!stack || !stack.members.length) {\n            this.safeToRemove();\n          }\n        });\n      }\n    }\n    return null;\n  }\n  componentDidUpdate() {\n    const {\n      projection\n    } = this.props.visualElement;\n    if (projection) {\n      projection.root.didUpdate();\n      microtask.postRender(() => {\n        if (!projection.currentAnimation && projection.isLead()) {\n          this.safeToRemove();\n        }\n      });\n    }\n  }\n  componentWillUnmount() {\n    const {\n      visualElement,\n      layoutGroup,\n      switchLayoutGroup: promoteContext\n    } = this.props;\n    const {\n      projection\n    } = visualElement;\n    hasTakenAnySnapshot = true;\n    if (projection) {\n      projection.scheduleCheckAfterUnmount();\n      if (layoutGroup && layoutGroup.group) layoutGroup.group.remove(projection);\n      if (promoteContext && promoteContext.deregister) promoteContext.deregister(projection);\n    }\n  }\n  safeToRemove() {\n    const {\n      safeToRemove\n    } = this.props;\n    safeToRemove && safeToRemove();\n  }\n  render() {\n    return null;\n  }\n}\nfunction MeasureLayout(props) {\n  const [isPresent, safeToRemove] = usePresence();\n  const layoutGroup = useContext(LayoutGroupContext);\n  return jsx(MeasureLayoutWithContext, {\n    ...props,\n    layoutGroup: layoutGroup,\n    switchLayoutGroup: useContext(SwitchLayoutGroupContext),\n    isPresent: isPresent,\n    safeToRemove: safeToRemove\n  });\n}\nexport { MeasureLayout };","map":{"version":3,"names":["jsx","frame","microtask","useContext","Component","usePresence","LayoutGroupContext","SwitchLayoutGroupContext","globalProjectionState","hasTakenAnySnapshot","MeasureLayoutWithContext","componentDidMount","visualElement","layoutGroup","switchLayoutGroup","layoutId","props","projection","group","add","register","root","didUpdate","addEventListener","safeToRemove","setOptions","options","onExitComplete","hasEverUpdated","getSnapshotBeforeUpdate","prevProps","layoutDependency","drag","isPresent","undefined","willUpdate","promote","relegate","postRender","stack","getStack","members","length","componentDidUpdate","currentAnimation","isLead","componentWillUnmount","promoteContext","scheduleCheckAfterUnmount","remove","deregister","render","MeasureLayout"],"sources":["C:/Users/yangt/Desktop/tyang_portfolio/node_modules/framer-motion/dist/es/motion/features/layout/MeasureLayout.mjs"],"sourcesContent":["\"use client\";\nimport { jsx } from 'react/jsx-runtime';\nimport { frame, microtask } from 'motion-dom';\nimport { useContext, Component } from 'react';\nimport { usePresence } from '../../../components/AnimatePresence/use-presence.mjs';\nimport { LayoutGroupContext } from '../../../context/LayoutGroupContext.mjs';\nimport { SwitchLayoutGroupContext } from '../../../context/SwitchLayoutGroupContext.mjs';\nimport { globalProjectionState } from '../../../projection/node/state.mjs';\n\n/**\n * Track whether we've taken any snapshots yet. If not,\n * we can safely skip notification of didUpdate.\n *\n * Difficult to capture in a test but to prevent flickering\n * we must set this to true either on update or unmount.\n * Running `next-env/layout-id` in Safari will show this behaviour if broken.\n */\nlet hasTakenAnySnapshot = false;\nclass MeasureLayoutWithContext extends Component {\n    /**\n     * This only mounts projection nodes for components that\n     * need measuring, we might want to do it for all components\n     * in order to incorporate transforms\n     */\n    componentDidMount() {\n        const { visualElement, layoutGroup, switchLayoutGroup, layoutId } = this.props;\n        const { projection } = visualElement;\n        if (projection) {\n            if (layoutGroup.group)\n                layoutGroup.group.add(projection);\n            if (switchLayoutGroup && switchLayoutGroup.register && layoutId) {\n                switchLayoutGroup.register(projection);\n            }\n            if (hasTakenAnySnapshot) {\n                projection.root.didUpdate();\n            }\n            projection.addEventListener(\"animationComplete\", () => {\n                this.safeToRemove();\n            });\n            projection.setOptions({\n                ...projection.options,\n                onExitComplete: () => this.safeToRemove(),\n            });\n        }\n        globalProjectionState.hasEverUpdated = true;\n    }\n    getSnapshotBeforeUpdate(prevProps) {\n        const { layoutDependency, visualElement, drag, isPresent } = this.props;\n        const { projection } = visualElement;\n        if (!projection)\n            return null;\n        /**\n         * TODO: We use this data in relegate to determine whether to\n         * promote a previous element. There's no guarantee its presence data\n         * will have updated by this point - if a bug like this arises it will\n         * have to be that we markForRelegation and then find a new lead some other way,\n         * perhaps in didUpdate\n         */\n        projection.isPresent = isPresent;\n        hasTakenAnySnapshot = true;\n        if (drag ||\n            prevProps.layoutDependency !== layoutDependency ||\n            layoutDependency === undefined ||\n            prevProps.isPresent !== isPresent) {\n            projection.willUpdate();\n        }\n        else {\n            this.safeToRemove();\n        }\n        if (prevProps.isPresent !== isPresent) {\n            if (isPresent) {\n                projection.promote();\n            }\n            else if (!projection.relegate()) {\n                /**\n                 * If there's another stack member taking over from this one,\n                 * it's in charge of the exit animation and therefore should\n                 * be in charge of the safe to remove. Otherwise we call it here.\n                 */\n                frame.postRender(() => {\n                    const stack = projection.getStack();\n                    if (!stack || !stack.members.length) {\n                        this.safeToRemove();\n                    }\n                });\n            }\n        }\n        return null;\n    }\n    componentDidUpdate() {\n        const { projection } = this.props.visualElement;\n        if (projection) {\n            projection.root.didUpdate();\n            microtask.postRender(() => {\n                if (!projection.currentAnimation && projection.isLead()) {\n                    this.safeToRemove();\n                }\n            });\n        }\n    }\n    componentWillUnmount() {\n        const { visualElement, layoutGroup, switchLayoutGroup: promoteContext, } = this.props;\n        const { projection } = visualElement;\n        hasTakenAnySnapshot = true;\n        if (projection) {\n            projection.scheduleCheckAfterUnmount();\n            if (layoutGroup && layoutGroup.group)\n                layoutGroup.group.remove(projection);\n            if (promoteContext && promoteContext.deregister)\n                promoteContext.deregister(projection);\n        }\n    }\n    safeToRemove() {\n        const { safeToRemove } = this.props;\n        safeToRemove && safeToRemove();\n    }\n    render() {\n        return null;\n    }\n}\nfunction MeasureLayout(props) {\n    const [isPresent, safeToRemove] = usePresence();\n    const layoutGroup = useContext(LayoutGroupContext);\n    return (jsx(MeasureLayoutWithContext, { ...props, layoutGroup: layoutGroup, switchLayoutGroup: useContext(SwitchLayoutGroupContext), isPresent: isPresent, safeToRemove: safeToRemove }));\n}\n\nexport { MeasureLayout };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}